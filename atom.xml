<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>李雨的个人笔记</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.betterliyu.site/"/>
  <updated>2019-12-10T05:57:44.136Z</updated>
  <id>https://blog.betterliyu.site/</id>
  
  <author>
    <name>李雨 LiYu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>js实现无限调用的柯里化函数</title>
    <link href="https://blog.betterliyu.site/2019/04/26/js%E5%AE%9E%E7%8E%B0%E6%97%A0%E9%99%90%E8%B0%83%E7%94%A8%E7%9A%84%E6%9F%AF%E9%87%8C%E5%8C%96%E5%87%BD%E6%95%B0/"/>
    <id>https://blog.betterliyu.site/2019/04/26/js实现无限调用的柯里化函数/</id>
    <published>2019-04-26T16:11:39.000Z</published>
    <updated>2019-12-10T05:57:44.136Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> initialValue = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> plus = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Number</span>.isInteger(value)) &#123;</span><br><span class="line">      initialValue += value;</span><br><span class="line">      <span class="keyword">return</span> plus;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> initialValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> plus(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">1</span>)(<span class="number">1</span>)();</span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span 
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://blog.betterliyu.site/categories/JavaScript/"/>
    
    
      <category term="函数式编程" scheme="https://blog.betterliyu.site/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="柯里化" scheme="https://blog.betterliyu.site/tags/%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>chrome-devtool 远程调试iOS网页</title>
    <link href="https://blog.betterliyu.site/2018/09/22/chrome-devtool-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95iOS%E7%BD%91%E9%A1%B5/"/>
    <id>https://blog.betterliyu.site/2018/09/22/chrome-devtool-远程调试iOS网页/</id>
    <published>2018-09-22T15:34:29.000Z</published>
    <updated>2019-12-10T05:57:44.132Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用-chrome-devtool-上调试-iOS-Safari-网页"><a href="#使用-chrome-devtool-上调试-iOS-Safari-网页" class="headerlink" title="使用 chrome devtool 上调试 iOS Safari 网页"></a>使用 chrome devtool 上调试 iOS Safari 网页</h2><h4 id="1-安装-iTunes"><a href="#1-安装-iTunes" class="headerlink" title="1. 安装 iTunes"></a>1. 安装 <a href="https://www.apple.com/itunes/download/" target="_blank" rel="noopener">iTunes</a></h4><p>  安装 iTunes 时会同时安装驱动程序。不是在 Window App Store 中安装。点击直接<a href="https://secure-appldnld.apple.com/itunes12/041-44313-20190325-EF444F04-4E71-11E9-8702-7A4824A43337/iTunes64Setup.exe" target="_blank" rel="noopener">下载</a>。<br>  <img src="apple-install.png" alt="iTunes驱动程序"></p><h4 id="2-安装-Node-js"><a href="#2-安装-Node-js" class="headerlink" title="2. 安装 Node.js"></a>2. 安装 <a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">Node.js</a></h4><p>  需要勾选安装 npm。</p><h4 id="3-安装-remotedebug-ios-webkit-adapter"><a href="#3-安装-remotedebug-ios-webkit-adapter" class="headerlink" title="3. 安装 remotedebug-ios-webkit-adapter"></a>3. 安装 remotedebug-ios-webkit-adapter</h4><p>  前往 <a href="https://github.com/RemoteDebug/remotedebug-ios-webkit-adapter" target="_blank" rel="noopener">remotedebug-ios-webkit-adapter</a> 按照步骤安装各个依赖包。<br>  Scoop 安装参考 <a href="https://github.com/lukesampson/scoop" target="_blank" rel="noopener">Scoop 主页</a>。 </p><h4 id="4-设置-iphone。"><a href="#4-设置-iphone。" class="headerlink" title="4. 设置 iphone。"></a>4. 设置 iphone。</h4><p>  打开 设置 》 Safari浏览器 》 高级，开启 Web检查器。将 iphone 使用数据线连接到电脑。如果是第一次连接，需要在 iphone 和 电脑上信任设备。 </p><h4 id="5-启动-iosAdapter"><a href="#5-启动-iosAdapter" class="headerlink" title="5. 启动 iosAdapter"></a>5. 启动 iosAdapter</h4><p>  确保连接成功之后，打开 PowerShell 并执行命令 <code>remotedebug_ios_webkit_adapter --port=9000</code>。 如果 windows 询问是否允许访问网络，点击允许即可。   </p><blockquote><p>如果你安装的 remotedebug_ios_webkit_adapter 是0.3.2及以前的版本，同时安装scoop时修改了默认安装路径，在启动后会提示:<br>    <code>remotedebug-ios-webkit-adapter failed to run with the following error: ios_webkit_debug_proxy.exe not found. Please install &#39;scoop install ios-webkit-debug-proxy&#39;</code><br>    参照这个修改 <a href="https://github.com/RemoteDebug/remotedebug-ios-webkit-adapter/pull/131" target="_blank" rel="noopener">fix(iosAdapter): fixed issue when user has custom scoop path #131</a>。    </p></blockquote><p>  启动成功出现如下界面：<br>  <img src="ps.png" alt="启动 iosAdapter"></p><h4 id="6-设置-Target-discovery-settings"><a href="#6-设置-Target-discovery-settings" class="headerlink" title="6. 设置 Target discovery settings"></a>6. 设置 Target discovery settings</h4><p>  打开 chrome://inspect/#devices，点击 configure，将 localhost:9000 添加到列表中。<br>  <img src="chrome-inspect.png" alt="chrome://inspect/#devices"><br>  此时在手机上打开 Safari，访问要测试的网页，稍等片刻，chrome 会出现手机上访问的网页。点击inspect 即可调试。<br>  <img src="remote-target.png" alt="手机打开的网页"></p><h4 id="7-遇到的问题"><a href="#7-遇到的问题" class="headerlink" title="7. 遇到的问题"></a>7. 遇到的问题</h4><ul><li>升级 ios 12.2 调试有问题，Remote target 不会出现网页列表。暂时(2019/04/13)没有找到解决方法。</li><li>如果打开 devtool 出现 404 或者空白，需要科学上网。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用-chrome-devtool-上调试-iOS-Safari-网页&quot;&gt;&lt;a href=&quot;#使用-chrome-devtool-上调试-iOS-Safari-网页&quot; class=&quot;headerlink&quot; title=&quot;使用 chrome devtool 上调试 
      
    
    </summary>
    
      <category term="开发工具" scheme="https://blog.betterliyu.site/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="chrome devtool" scheme="https://blog.betterliyu.site/tags/chrome-devtool/"/>
    
      <category term="移动端" scheme="https://blog.betterliyu.site/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
      <category term="debug" scheme="https://blog.betterliyu.site/tags/debug/"/>
    
  </entry>
  
  <entry>
    <title>CSS学习笔记(二): overflow</title>
    <link href="https://blog.betterliyu.site/2018/05/17/CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C-overflow/"/>
    <id>https://blog.betterliyu.site/2018/05/17/CSS学习笔记-二-overflow/</id>
    <published>2018-05-17T18:43:05.000Z</published>
    <updated>2019-12-10T05:57:44.132Z</updated>
    
    <content type="html"><![CDATA[<h2 id="overflow-基本概念"><a href="#overflow-基本概念" class="headerlink" title="overflow 基本概念"></a>overflow 基本概念</h2><p>overflow在内容超出自身尺寸时，决定内容将如何显示。</p><ul><li>visible (默认)</li><li>hidden 隐藏超出部分</li><li>scroll 始终出现滚动条</li><li>auto 浏览器决定</li><li>inherit (IE8+) 继承</li></ul><h3 id="overflow-x-和-overflow-y-IE8"><a href="#overflow-x-和-overflow-y-IE8" class="headerlink" title="overflow-x 和 overflow-y (IE8+)"></a>overflow-x 和 overflow-y (IE8+)</h3><p>取值和overflow一致，并分别作用于x轴和y轴。</p><blockquote><p>注意：如果overflow-x和overflow-y的值不同，其中一个visible，另外一个为非visible，则visible会被重置为auto。  </p></blockquote><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><p>容器需要满足以下条件，overflow才能起作用  </p><ul><li>非display: inline;</li><li>对应方位的尺寸限制。width/height/max-width/man-height/absolute拉伸</li><li>对于单元格td等。还需要<code>table</code>属性为<code>table-layout: fixed</code>;</li></ul><h3 id="viewport-html-和-body-的overflow"><a href="#viewport-html-和-body-的overflow" class="headerlink" title="viewport, html 和 body 的overflow"></a>viewport, html 和 body 的overflow</h3><p>当我们通过检查元素查看最外层的滚动条时，会发现它既不会被包含在body内部也不会被包含在html元素内。这是因为这个滚动条是viewport提供给我们的，而且渲染的机制也不单纯。看<a href="https://www.w3.org/TR/CSS2/visufx.html#q11.0" target="_blank" rel="noopener">规范</a>：</p><blockquote><p>UAs must apply the ‘overflow’ property set on the root element to the viewport. When the root element is an HTML “HTML” element or an XHTML “html” element, and that element has an HTML “BODY” element or an XHTML “body” element as a child, user agents must instead apply the ‘overflow’ property from the first such child element to the viewport, if the value on the root element is ‘visible’. The ‘visible’ value when used for the viewport must be interpreted as ‘auto’. The element from which the value is propagated must have a used value for ‘overflow’ of ‘visible’.</p></blockquote><p>看着有点费解，大体可以理解为四点：</p><ol><li>直接将根元素（通常为html）的overflow属性应用到viewport上；</li><li>如果根元素是html，body是html子元素，并且html元素overflow为<code>visible</code>，则会将第一个body元素的overflow属性应用到viewport上；</li><li>viewport上overflow: <code>visible</code>会被当做<code>auto</code>;</li><li>如果触发了第二条，body元素的overflow值将使用 <code>visible</code>渲染。</li></ol><hr><h2 id="overflow-与滚动条"><a href="#overflow-与滚动条" class="headerlink" title="overflow 与滚动条"></a>overflow 与滚动条</h2><p>当overflow值为auto/scroll，并且内容尺寸超过容器尺寸限制时会出现滚动条。</p><h3 id="滚动条的样式在各个浏览器中有一定的差异。"><a href="#滚动条的样式在各个浏览器中有一定的差异。" class="headerlink" title="滚动条的样式在各个浏览器中有一定的差异。"></a>滚动条的样式在各个浏览器中有一定的差异。</h3><blockquote><p>获取滚动条的宽度：宽度 - 可视区域宽度(clientWidth)<br>   结果：IE11/Chrome/Firefox(win10)：17px；Edge：16px  </p></blockquote><blockquote><p>注意：滚动条出现之后容器大小会发生变化，可能会导致另外一个方向也出现滚动条。</p></blockquote><h3 id="自定义滚动条"><a href="#自定义滚动条" class="headerlink" title="自定义滚动条"></a>自定义滚动条</h3><h4 id="webkit"><a href="#webkit" class="headerlink" title="webkit"></a>webkit</h4><table><thead><tr><th>属性</th><th>含义 </th></tr></thead><tbody><tr><td><code>::-webkit-scrollbar</code></td><td>整体部分  </td></tr><tr><td><code>::-webkit-scrollbar-button</code></td><td>两端按钮   </td></tr><tr><td><code>::-webkit-scrollbar-track</code></td><td>外层轨道   </td></tr><tr><td><code>::-webkit-scrollbar-track-piece</code></td><td>内层轨道   </td></tr><tr><td><code>::-webkit-scrollbar-thumb</code></td><td>滚动滑块 </td></tr><tr><td><code>::-webkit-scrollbar-corner</code></td><td>边角       </td></tr><tr><td><code>::-webkit-resizer</code></td><td>右下角拖动块</td></tr></tbody></table><h4 id="IE"><a href="#IE" class="headerlink" title="IE"></a>IE</h4><p>IE下只能修改滚动条的颜色。</p><table><thead><tr><th>属性</th><th>含义 </th></tr></thead><tbody><tr><td><code>scrollbar-arrow-color: color;</code></td><td>三角箭头的颜色 </td></tr><tr><td><code>scrollbar-face-color: color;</code></td><td>立体滚动条的颜色（包括箭头部分的背景色）</td></tr><tr><td><code>scrollbar-3dlight-color: color;</code></td><td>立体滚动条亮边的颜色</td></tr><tr><td><code>scrollbar-highlight-color: color;</code></td><td>滚动条的高亮颜色</td></tr><tr><td><code>scrollbar-shadow-color: color;</code></td><td>立体滚动条阴影的颜色</td></tr><tr><td><code>scrollbar-darkshadow-color: color;</code></td><td>立体滚动条外阴影的颜色</td></tr><tr><td><code>scrollbar-track-color: color;</code></td><td>立体滚动条背景颜色</td></tr><tr><td><code>scrollbar-base-color:color;</code></td><td>滚动条的基色</td></tr></tbody></table><blockquote><p>iOS原生滚动bounce效果: <code>-webkit-overflow-scrolling: touch</code></p></blockquote><h3 id="javascript-控制滚动"><a href="#javascript-控制滚动" class="headerlink" title="javascript 控制滚动"></a>javascript 控制滚动</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取滚动条位置</span></span><br><span class="line"><span class="comment">// 标准模式</span></span><br><span class="line"><span class="keyword">var</span> top = <span class="built_in">document</span>.documentElement.scrollTop;</span><br><span class="line"><span class="keyword">var</span> left = <span class="built_in">document</span>.documentElement.scrollLeft;</span><br><span class="line"><span class="comment">// 怪异模式</span></span><br><span class="line"><span class="keyword">var</span> top = <span class="built_in">document</span>..scrollTop;</span><br><span class="line"><span class="keyword">var</span> left = <span class="built_in">document</span>.body.scrollLeft;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置滚动条位置</span></span><br><span class="line"><span class="built_in">document</span>.documentElement.scrollTop = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">document</span>.body.scrollTop = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">window</span>.scrollTo(<span class="number">100</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><blockquote><p>注意: 即使设置了值为hidden，也可以通过js使内容滚动。</p></blockquote><h3 id="竖直滚动条导致固定宽度水平居中跳动的问题"><a href="#竖直滚动条导致固定宽度水平居中跳动的问题" class="headerlink" title="竖直滚动条导致固定宽度水平居中跳动的问题"></a>竖直滚动条导致固定宽度水平居中跳动的问题</h3><p>两中方式可以避免这种问题：</p><ol><li>始终出现滚动条<br><code>html { overflow-y: scroll }</code>  </li><li>居中元素的父元素设置margin或padding<br><code>padding-left: calc(100vw - 100%);</code><br><code>margin-left: calc(100vw - 100%);</code><br>100vw: 浏览器宽度；<br>100%: 可用内容宽度</li></ol><p>查看<a href="https://sample.betterliyu.site/css-note/overflow/horizontal_center_fixed_width_element_shake.html" target="_blank" rel="noopener">demo</a></p><hr><h2 id="overflow-与-BFC"><a href="#overflow-与-BFC" class="headerlink" title="overflow 与 BFC"></a>overflow 与 BFC</h2><p>值为 <code>auto</code>, <code>scroll</code> 和 <code>hidden</code> 可以触发 BFC，<code>visible</code> 不可以。一般常见的有以下三种应用场景：  </p><ul><li>清除浮动</li><li>避免margin穿透问题</li><li>两栏自适应布局</li></ul><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span> &#123; <span class="attribute">overflow</span>: hidden; <span class="attribute">_zoom</span>: <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure><p>以上写法有弊端，会隐藏超出容器的元素，一般这样写：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.clearfix &#123; *zoom: 1 &#125;</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123; <span class="attribute">content</span>: <span class="string">''</span>; <span class="attribute">display</span>: table; <span class="attribute">clear</span>: both; &#125;</span><br></pre></td></tr></table></figure></p><h3 id="避免-margin-穿透"><a href="#避免-margin-穿透" class="headerlink" title="避免 margin 穿透"></a>避免 margin 穿透</h3><p>任何触发BFC的行为都可以避免margin穿透。</p><h3 id="两栏自适应布局"><a href="#两栏自适应布局" class="headerlink" title="两栏自适应布局"></a>两栏自适应布局</h3><p>利用BFC的特性实现两栏自适应布局。</p><p>html代码<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>css代码<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#eee</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>查看<a href="https://sample.betterliyu.site/css-note/overflow/two_column_layout.html" target="_blank" rel="noopener">demo</a></p><h2 id="overflow-与-absolute-绝对定位"><a href="#overflow-与-absolute-绝对定位" class="headerlink" title="overflow 与 absolute 绝对定位"></a>overflow 与 absolute 绝对定位</h2><p>当overflow元素处于absolute元素和absolute元素的包含块之间时，会导致overflow元素剪裁或滚动失效。HTML基本结构如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>        <span class="comment">&lt;!-- absolute元素的包含块 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>       <span class="comment">&lt;!-- overflow元素 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span>/&gt;</span>    <span class="comment">&lt;!-- absolute元素 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><ul><li><p>剪裁失效</p><iframe height="300" src="https://sample.betterliyu.site/css-note/overflow/overflow_absolute_not_clip.html"></iframe></li><li><p>滚动失效</p><iframe height="400" src="https://sample.betterliyu.site/css-note/overflow/overflow_absolute_not_scroll.html"></iframe><blockquote><p>可以利用这样的特性来实现在scroll元素内部固定定位（类似于fixed）的效果。</p></blockquote></li></ul><h2 id="overflow-其他小技巧和问题"><a href="#overflow-其他小技巧和问题" class="headerlink" title="overflow 其他小技巧和问题"></a>overflow 其他小技巧和问题</h2><p>overflow不仅仅可以控制是否出现滚动条，还有其他意想不到的效果。</p><ul><li><p>IE6下，固定按钮padding<br>IE6浏览器下，文字越多，按钮两侧padding留白就越大，设置visible后padding就不会变大了。</p></li><li><p>overflow的padding-bottom缺失现象<br>非Chrome浏览器中，如果容器出现竖直滚动条并且有padding-bottom，会被忽略。<br>html代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>css代码</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="selector-class">.wrap</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: auto;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid gray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>:cornflowerblue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><iframe height="320" src="https://sample.betterliyu.site/css-note/overflow/padding_bottom_disappeared.html"></iframe></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;overflow-基本概念&quot;&gt;&lt;a href=&quot;#overflow-基本概念&quot; class=&quot;headerlink&quot; title=&quot;overflow 基本概念&quot;&gt;&lt;/a&gt;overflow 基本概念&lt;/h2&gt;&lt;p&gt;overflow在内容超出自身尺寸时，决定内容将如何
      
    
    </summary>
    
      <category term="CSS" scheme="https://blog.betterliyu.site/categories/CSS/"/>
    
    
      <category term="CSS" scheme="https://blog.betterliyu.site/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>CSS学习笔记(一): Hello CSS</title>
    <link href="https://blog.betterliyu.site/2017/11/07/CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80-Hello%20CSS/"/>
    <id>https://blog.betterliyu.site/2017/11/07/CSS学习笔记-一-Hello CSS/</id>
    <published>2017-11-07T18:43:05.000Z</published>
    <updated>2019-12-10T05:57:44.132Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h2><p>内联样式定义在HTML标签的style属性中。除了在body外的标签，style属性可以定义在任何一个HTML标签中。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"color: red;font-size: 14px;"</span>&gt;</span>文字<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这样定义的样式只作用于这个div，不会影响到div以外的内容。内联style属性中只能放CSS样式规则大括号之内的键值对，也不能包含@import指令。通常不推荐使用内联样式，如果这样做的话会使HTML变得混乱，会使CSS灵活性大大的降低。</p><hr><h2 id="style标签"><a href="#style标签" class="headerlink" title="style标签"></a>style标签</h2><p>也可以使用style标签定义样式。它以HTML标签的形式出现在head标签内。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  body &#123;</span></span><br><span class="line"><span class="undefined">    color: red;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">  </span></span><br><span class="line"><span class="undefined">  div &#123;</span></span><br><span class="line"><span class="undefined">    font-size: 14px;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">  </span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这样定义的样式作用于全局，标签内定义的样式可以称为文档样式表。其中可以包含多组样式，也可以使用@import指令包含多个样式表链接。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li>type: 表示类型，一般值为text/css，描述加载的数据类型，浏览器通过这个属性识别样式表是CSS样式表</li><li>media: 定义当前样式应用的媒体类型，下一章详细说明</li></ul><hr><h2 id="link标签"><a href="#link标签" class="headerlink" title="link标签"></a>link标签</h2><p>link标签用来引用外部样式表，应该优先考虑使用。</p><p>index.html<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"sheet1.css"</span> <span class="attr">title</span>=<span class="string">"Default"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>sheet1.css</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;  </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样定义的样式是一个独立的外部文件，通过link标签可以应用到当前的文档中。link标签必须是head标签的子元素。外部样式表中不能包含除CSS规则和CSS注释以外的任何标记，如果出现，会导致部分CSS规则会被忽略。<br>外部样式一般以<code>.css</code>为文件名后缀，也不是必须的。但是一些老版本的浏览器无法识别包含样式表的文件，除非以<code>.css</code>为扩展名。</p><h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><p>常见的link标签的属性有<code>rel</code>，<code>type</code>，<code>href</code>和<code>media</code>等。这里主要说明和样式相关的属性和属性值。</p><h4 id="rel"><a href="#rel" class="headerlink" title="rel"></a>rel</h4><p>rel属性表示外部文件和当前文档的关系，值通常设置为<code>stylesheet</code>，表示外部文件是样式表。除了<code>stylesheet</code>，rel属性还有其他可选值。</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>alternate</td><td>链接到该文档的替代版本（例如打印页、翻译或镜像）</td></tr><tr><td>author</td><td>链接到该文档的作者。</td></tr><tr><td>help</td><td>链接到帮助文档。</td></tr><tr><td>icon</td><td>表示该文档的图标。</td></tr><tr><td>licence</td><td>链接到该文档的版权信息。</td></tr><tr><td>next</td><td>集合中的下一个文档。</td></tr><tr><td>pingback</td><td>指向 pingback 服务器的 URL。</td></tr><tr><td>prefetch</td><td>规定应该对目标文档进行缓存。</td></tr><tr><td>prev</td><td>集合中的前一个文档。</td></tr><tr><td>search</td><td>链接到针对文档的搜索工具。</td></tr><tr><td>sidebar</td><td>链接到应该显示在浏览器侧栏的文档。</td></tr><tr><td>stylesheet</td><td>指向要导入的样式表的 URL。</td></tr><tr><td>tag</td><td>描述当前文档的标签（关键词）。</td></tr></tbody></table><p>这里要特地说明的是<code>alternate</code>，可以利用这一属性设置网页候选样式<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"alternate stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"sheet1.css"</span> <span class="attr">title</span>=<span class="string">"Default"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>像上面的代码一样，设置<code>rel=&quot;alternate stylesheet&quot;</code>，同时设置title属性，就会有一个主题为<code>Default</code>的候选样式供选择。大多数Geckco内核的浏览器支持这一功能，你可以在火狐浏览器“查看&gt;页面样式”菜单中找到。<code>title</code>属性是全局属性，每个标签都可以定义，但是定义在link标签中则表示样式的主题，也可以定义多个同一主题文件。</p><h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p>type属性表示类型文件，值通常为<code>text/css</code>，描述加载的文件类型，浏览器通过这个属性识别样式表是CSS样式表。</p><h4 id="href"><a href="#href" class="headerlink" title="href"></a>href</h4><p>href属性表示样式文件的URL，可以是绝对路径也可以是相对路径。</p><h4 id="hreflang"><a href="#hreflang" class="headerlink" title="hreflang"></a>hreflang</h4><p>hreflang属性表示链接文档的语言类型。</p><h4 id="media"><a href="#media" class="headerlink" title="media"></a>media</h4><p>media属性表示当前样式将要应用到什么样的媒体设备上。它的值需要符合媒体查询列表的格式。现代Web浏览器主要支持媒体类型的值主要是<code>all</code>，<code>screen</code>和<code>print</code>，在全屏模式中，Opera 也支持 <code>projection</code>属性值。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 表示在屏幕设备上应用该样式，其他媒体类型无效 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"sheet1.css"</span> <span class="attr">media</span>=<span class="string">"screen"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>也可以设置多个值<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 表示在屏幕设备上和打印时应用该样式，其他媒体类型无效 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"sheet1.css"</span> <span class="attr">media</span>=<span class="string">"screen, print"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><code>all</code>表示所有设备都使用该样式，其他不常用的值有：</p><ul><li><code>aural</code>：用于语音合成器，屏幕阅读器和文档的其他声音表现</li><li><code>braille</code>：用Braille设备表现文档时使用</li><li><code>embossed</code>：用Braille打印设备打印时使用</li><li><code>handheld</code>：用于手持设备，如个人数字助理或支持Web的蜂窝电话</li><li><code>projection</code>：用于投影媒体</li><li><code>tty</code>：在固定间距环境中（如电传打字机）显示文档时使用</li><li><code>tv</code>：在电视上显示文档时使用</li></ul><p>HTML5之后，这个属性可以设置更多的值，值必须是media query list。参照CSS3的媒体查询。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 表示在屏幕设备上和打印时应用该样式，其他媒体类型无效 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"sheet1.css"</span> <span class="attr">media</span>=<span class="string">"screen, print"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>可能的操作符</strong></p><table><thead><tr><th>值</th><th>描述 </th></tr></thead><tbody><tr><td>and</td><td>规定 AND 操作符</td></tr><tr><td>not</td><td>规定 NOT 操作符</td></tr><tr><td>,</td><td>规定 OR 操作符</td></tr></tbody></table><p><strong>设备</strong></p><table><thead><tr><th>值</th><th>描述 </th></tr></thead><tbody><tr><td>all</td><td>默认。适用于所有设备。</td></tr><tr><td>aural</td><td>语音合成器。</td></tr><tr><td>braille</td><td>盲文反馈装置。</td></tr><tr><td>handheld</td><td>手持设备（小屏幕、有限的带宽）。</td></tr><tr><td>projection</td><td>投影机。</td></tr><tr><td>print</td><td>打印预览模式/打印页。</td></tr><tr><td>screen</td><td>计算机屏幕。</td></tr><tr><td>tty</td><td>电传打字机以及类似的使用等宽字符网格的媒介。</td></tr><tr><td>tv</td><td>电视类型设备（低分辨率、有限的滚屏能力）。</td></tr></tbody></table><p><strong>属性值</strong></p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>width</td><td>规定目标显示区域的宽度。可使用 “min-“ 和 “max-“ 前缀。例子：<code>media=&quot;screen and (min-width:500px)&quot;</code></td></tr><tr><td>height</td><td>规定目标显示区域的高度。可使用 “min-“ 和 “max-“ 前缀。例子：<code>media=&quot;screen and (max-height:700px)&quot;</code></td></tr><tr><td>device-width</td><td>规定目标显示器/纸张的宽度。可使用 “min-“ 和 “max-“ 前缀。例子：<code>media=&quot;screen and (device-width:500px)&quot;</code></td></tr><tr><td>device-height</td><td>规定目标显示器/纸张的高度。可使用 “min-“ 和 “max-“ 前缀。例子：<code>media=&quot;screen and (device-height:500px)&quot;</code></td></tr><tr><td>orientation</td><td>规定目标显示器/纸张的方向。可能的值：”portrait” or “landscape”例子：<code>media=&quot;all and (orientation: landscape)&quot;</code></td></tr><tr><td>aspect-ratio</td><td>规定目标显示区域的宽度/高度比可使用 “min-“ 和 “max-“ 前缀。例子：<code>media=&quot;screen and (aspect-ratio:16/9)&quot;</code></td></tr><tr><td>device-aspect-ratio</td><td>规定目标显示器/纸张的 device-width/device-height 比率可使用 “min-“ 和 “max-“ 前缀。例子：<code>media=&quot;screen and (aspect-ratio:16/9)&quot;</code></td></tr><tr><td>color</td><td>规定目标显示器的 bits/color。可使用 “min-“ 和 “max-“ 前缀。例子：<code>media=&quot;screen and (color:3)&quot;</code></td></tr><tr><td>color-index</td><td>规定目标显示器可以处理的颜色数。可使用 “min-“ 和 “max-“ 前缀。例子：<code>media=&quot;screen and (min-color-index:256)&quot;</code></td></tr><tr><td>monochrome</td><td>规定单色帧缓冲中的 bits/pixel。可使用 “min-“ 和 “max-“ 前缀。例子：<code>media=&quot;screen and (monochrome:2)&quot;</code></td></tr><tr><td>resolution</td><td>规定目标显示器/纸张的像素密度 (dpi 或 dpcm)。可使用 “min-“ 和 “max-“ 前缀。例子：<code>media=&quot;print and (resolution:300dpi)&quot;</code></td></tr><tr><td>scan</td><td>规定 tv 显示器的扫描方式。可能的值：”progressive” 和 “interlace”。例子：<code>media=&quot;tv and (scan:interlace)&quot;</code></td></tr><tr><td>grid</td><td>规定输出设备是否是网格或位图。可能的值：”1” 为网格，否则为 “0”。例子：<code>media=&quot;handheld and (grid:1)&quot;</code></td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 表示在宽度大于768px的屏幕设备上应用该样式，其他媒体类型无效 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"sheet1.css"</span> <span class="attr">media</span>=<span class="string">"screen and (min-width:768px)"</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="import"><a href="#import" class="headerlink" title="@import"></a>@import</h2><p>@import指令用来从外部加载样式文件，类似link标签，但是和link标签还是有很多区别的。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 以下三种方式都是正确的，相对路径和绝对路径都可以*/</span></span><br><span class="line"><span class="comment">/* 1 */</span></span><br><span class="line">@<span class="keyword">import</span> url(sheet2.css);</span><br><span class="line"><span class="comment">/* 2 */</span></span><br><span class="line">@<span class="keyword">import</span> url(<span class="string">"sheet2.css"</span>);</span><br><span class="line"><span class="comment">/* 3 */</span></span><br><span class="line">@<span class="keyword">import</span> sheet2.css;</span><br></pre></td></tr></table></figure></p><p>@import指令只能用于style标签内或者css样式文件中，并且必须出现在其他的css规则之前，否则浏览器可能会忽略@import指令。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">import</span> url(index02.css);</span><br></pre></td></tr></table></figure></p><p>上面代码中@import指令将会被忽略。</p><p>只要是通过@import指令正确导入的外部样式表都会加载，无法指定候选样式表，但是可以指定media媒体类型，直接在后面添加查询条件即可。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">import</span> url(index02.css) screen and (min-width:<span class="number">768px</span>);</span><br></pre></td></tr></table></figure></p><hr><h2 id="link和-import的区别"><a href="#link和-import的区别" class="headerlink" title="link和@import的区别"></a>link和@import的区别</h2><ol><li>最主要的区别在于lin是属于XHTML标签，除了可以引用样式文件，还可以引用icon等资源，详见rel属性，而@import则是css2.1中的语法特性，只能引用css</li><li>加载顺序不同，link加载的css时，是一种并行加载CSS方式，而@import则在整个页面加载完成后才加载</li><li>兼容性的区别，@import是CSS2.1才特有的，部分浏览器不支持</li><li>link标签可以通过javascript控制，而@import不能</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;内联样式&quot;&gt;&lt;a href=&quot;#内联样式&quot; class=&quot;headerlink&quot; title=&quot;内联样式&quot;&gt;&lt;/a&gt;内联样式&lt;/h2&gt;&lt;p&gt;内联样式定义在HTML标签的style属性中。除了在body外的标签，style属性可以定义在任何一个HTML标签中。&lt;br
      
    
    </summary>
    
      <category term="CSS" scheme="https://blog.betterliyu.site/categories/CSS/"/>
    
    
      <category term="CSS" scheme="https://blog.betterliyu.site/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>bwidget-timespinner配置文档</title>
    <link href="https://blog.betterliyu.site/2017/11/02/bwidget-timespinner%E9%85%8D%E7%BD%AE%E6%96%87%E6%A1%A3/"/>
    <id>https://blog.betterliyu.site/2017/11/02/bwidget-timespinner配置文档/</id>
    <published>2017-11-02T16:49:01.000Z</published>
    <updated>2019-12-10T05:57:44.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="bwidget-timespinner"><a href="#bwidget-timespinner" class="headerlink" title="bwidget-timespinner"></a>bwidget-timespinner</h1><hr><p>  这是一个使用原生javascript开发的时间微调控件，可以分别调节时分秒，并且兼容了中文输入法，限制输入非数字。兼容IE9以上浏览器。</p><p>  npm: <a href="https://www.npmjs.com/package/bwidget-timespinner" target="_blank" rel="noopener">https://www.npmjs.com/package/bwidget-timespinner</a><br>  github: <a href="https://github.com/betterliyu/timespinner" target="_blank" rel="noopener">https://github.com/betterliyu/timespinner</a></p><p>  <img src="2017-10-31_15h36_05.png" alt="示例图"></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li>npm安装<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install bwidget-timespinner --save</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>浏览器直接引用 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- style --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"css/bwidget.timespinner.css"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- script --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/bwidget.timespinner.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以通过github进行下载：<a href="https://github.com/betterliyu/timespinner" target="_blank" rel="noopener">https://github.com/betterliyu/timespinner</a></p></li></ol><hr><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li><p>初始化</p><ul><li>模块化开发</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'node_modules/bwidget-timespinner/dist/css/bwidget.timespinner.css'</span></span><br><span class="line"><span class="keyword">import</span> TimeSpinner <span class="keyword">from</span> <span class="string">'bwidget-timespinner'</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> timespinner = <span class="keyword">new</span> TimeSpinner(<span class="string">'#timespinner'</span>, &#123;</span><br><span class="line">  width: <span class="number">300</span>,</span><br><span class="line">  height: <span class="number">40</span>,</span><br><span class="line">  align: <span class="string">'center'</span>,</span><br><span class="line">  format: <span class="string">'hh:mm:ss'</span>,</span><br><span class="line">  second: <span class="number">1000</span>,</span><br><span class="line">  disabled: <span class="literal">false</span>,</span><br><span class="line">  onInput (obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(obj.preValue + <span class="string">' - '</span> + obj.newValue)</span><br><span class="line">  &#125;,</span><br><span class="line">  onValueChanged (obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(obj.preValue + <span class="string">' - '</span> + obj.newValue)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>全局变量方式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bwidget是全局变量</span></span><br><span class="line"><span class="keyword">var</span> timespinner = <span class="keyword">new</span> bwidget.timespinner(<span class="string">'#timespinner'</span>, &#123;&#125;)</span><br></pre></td></tr></table></figure></li><li><p>获取和设置</p><ul><li>获取属性： <code>var value = instance.prop</code></li><li>设置属性： <code>instance.prop = value</code></li></ul></li></ol><hr><h2 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><h4 id="align"><a href="#align" class="headerlink" title="align"></a><strong>align</strong></h4><blockquote><p>Type: <code>String</code><br>Default Value: <code>&#39;left&#39;</code><br>Accept Values: <code>css text-align value</code></p></blockquote><p>获取或设置控件的内容水平对齐方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> TimePicker(<span class="string">'#tp'</span>, &#123;&#125;)</span><br><span class="line"><span class="comment">// set</span></span><br><span class="line">instance.align = <span class="string">'right'</span></span><br><span class="line"><span class="comment">// get</span></span><br><span class="line"><span class="keyword">var</span> textAlign = instance.align</span><br></pre></td></tr></table></figure><h4 id="disabled"><a href="#disabled" class="headerlink" title="disabled"></a><strong>disabled</strong></h4><blockquote><p>Type: <code>Boolean</code><br>Default Value: <code>false</code></p></blockquote><p>设置或获取控件是否可用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> TimePicker(<span class="string">'#tp'</span>, &#123;&#125;)</span><br><span class="line"><span class="comment">// set</span></span><br><span class="line">instance.disabled = <span class="literal">true</span></span><br><span class="line"><span class="comment">// get</span></span><br><span class="line"><span class="keyword">var</span> disabled = instance.disabled</span><br></pre></td></tr></table></figure><h4 id="element"><a href="#element" class="headerlink" title="element"></a><strong>element</strong></h4><blockquote><p>Type: <code>Element</code><br><code>ReadOnly</code></p></blockquote><p>获取控件对应的DOM Element对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> TimePicker(<span class="string">'#tp'</span>, &#123;&#125;)</span><br><span class="line"><span class="comment">// get</span></span><br><span class="line"><span class="keyword">var</span> element = instance.element</span><br></pre></td></tr></table></figure><h4 id="format"><a href="#format" class="headerlink" title="format"></a><strong>format</strong></h4><blockquote><p>Type: <code>String</code><br>Default Value: <code>&#39;hh:mm:ss&#39;</code><br>Accepted Values: <code>&#39;hh:mm:ss&#39;</code> | <code>&#39;hh:mm&#39;</code> | <code>&#39;mm:ss&#39;</code> | <code>&#39;hh(max):mm:ss&#39;</code> | <code>&#39;hh(max):mm&#39;</code> | <code>&#39;mm(max):ss&#39;</code></p></blockquote><p>设置时间的格式。只能在初始化时设置。分为两种格式，不包含数字，表示采用默认大小，包含数字，表示设置最大小时或分钟数。最大值可以是任意数字。如果未指定则小时最大值为23(<code>&#39;hh(23):mm:ss&#39;</code>,<code>&#39;hh(23):mm&#39;</code>)，分钟最大值为59(<code>&#39;mm(59):ss&#39;</code>)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> TimePicker(<span class="string">'#tp'</span>, &#123;</span><br><span class="line">  <span class="comment">// set</span></span><br><span class="line">  format: <span class="string">'hh(99):mm:ss'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// get</span></span><br><span class="line"><span class="keyword">var</span> format = instance.format</span><br></pre></td></tr></table></figure><h4 id="height"><a href="#height" class="headerlink" title="height"></a><strong>height</strong></h4><blockquote><p>Type: <code>String</code> | <code>Number</code><br>Default Value: <code>&#39;100%&#39;</code><br>Accepted Values: <code>css value</code> | <code>number</code></p></blockquote><p>设置或获取控件的高度。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> TimePicker(<span class="string">'#tp'</span>, &#123;&#125;)</span><br><span class="line"><span class="comment">// set</span></span><br><span class="line">instance.height = <span class="number">200</span></span><br><span class="line"><span class="comment">// get</span></span><br><span class="line"><span class="keyword">var</span> height = instance.height</span><br></pre></td></tr></table></figure><h4 id="second"><a href="#second" class="headerlink" title="second"></a><strong>second</strong></h4><blockquote><p>Type: <code>Integer</code><br>Default Value: <code>0</code></p></blockquote><p>设置或获取时间的值。不同格式的时间都通过设置的秒进行转换。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> TimePicker(<span class="string">'#tp'</span>, &#123;&#125;)</span><br><span class="line"><span class="comment">// set</span></span><br><span class="line">instance.second = <span class="number">1000</span></span><br><span class="line"><span class="comment">// get</span></span><br><span class="line"><span class="keyword">var</span> sec = instance.second</span><br></pre></td></tr></table></figure><h4 id="width"><a href="#width" class="headerlink" title="width"></a><strong>width</strong></h4><blockquote><p>Type: <code>String</code> | <code>Number</code><br>Default Value: <code>&#39;100%&#39;</code><br>Accepted Values: <code>css value</code> | <code>number</code></p></blockquote><p>设置或获取控件的宽度。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> TimePicker(<span class="string">'#tp'</span>, &#123;&#125;)</span><br><span class="line"><span class="comment">// set</span></span><br><span class="line">instance.width = <span class="number">200</span></span><br><span class="line"><span class="comment">// get</span></span><br><span class="line"><span class="keyword">var</span> width = instance.width</span><br></pre></td></tr></table></figure><hr><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><h4 id="input"><a href="#input" class="headerlink" title="input"></a><strong>input</strong></h4><blockquote><p>Type: <code>function</code><br>Arguments: <code>[Object] { preValue, newValue }</code></p></blockquote><p>在控件的值被输入或点击上下箭头修改时触发。随后会触发<code>onValueChanged</code>事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> TimePicker(<span class="string">'#tp'</span>, &#123;</span><br><span class="line">  onInput: <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123; &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="valueChanged"><a href="#valueChanged" class="headerlink" title="valueChanged"></a><strong>valueChanged</strong></h4><p><code>v1.0.1</code></p><blockquote><p>Type: <code>function</code><br>Arguments: <code>[Object] { preValue, newValue }</code></p></blockquote><p>在控件的second值发生变化时触发。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> TimePicker(<span class="string">'#tp'</span>, &#123;</span><br><span class="line">  onValueChanged: <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123; &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><hr><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="text2Second"><a href="#text2Second" class="headerlink" title="text2Second"></a><strong>text2Second</strong></h4><blockquote><p>Arguments: <code>Time Format String(控件定义的格式)</code><br>Return Value: <code>second</code></p></blockquote><p>将时间字符串转换为对应的秒数。</p><h4 id="second2Text"><a href="#second2Text" class="headerlink" title="second2Text"></a><strong>second2Text</strong></h4><blockquote><p>Arguments: <code>second</code><br>Return Value: <code>Time Format String(控件定义的格式)</code></p></blockquote><p>将秒数转换为对应的时间字符串。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;bwidget-timespinner&quot;&gt;&lt;a href=&quot;#bwidget-timespinner&quot; class=&quot;headerlink&quot; title=&quot;bwidget-timespinner&quot;&gt;&lt;/a&gt;bwidget-timespinner&lt;/h1&gt;&lt;hr&gt;

      
    
    </summary>
    
      <category term="个人项目" scheme="https://blog.betterliyu.site/categories/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="timespinner" scheme="https://blog.betterliyu.site/tags/timespinner/"/>
    
  </entry>
  
  <entry>
    <title>AngularJS学习笔记：Provider和Service</title>
    <link href="https://blog.betterliyu.site/2017/07/15/AngularJS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Provider%E5%92%8CService/"/>
    <id>https://blog.betterliyu.site/2017/07/15/AngularJS学习笔记-Provider和Service/</id>
    <published>2017-07-15T17:13:34.000Z</published>
    <updated>2019-12-10T05:57:44.132Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>依赖注入是AngularJS的四大特性之一，在理解AngularJS如果实现依赖注入之前需要知道一些名词概念。</p><h3 id="Service（服务）"><a href="#Service（服务）" class="headerlink" title="Service（服务）"></a>Service（服务）</h3><p>服务是一些公共代码的集合（常量，变量，方法或对象），可以在控制器、指令等地方注入并使用。我们可以把控制器中重复的代码抽象成一个个服务的方法，通过服务来调用。AngularJS有许多内置的服务，比如<code>$http</code>服务提供ajax的操作，<code>$filter</code>提供数据过滤的操作等等。应用程序中所有服务保存在内部变量<code>instanceCache</code>中。关于Service有一下几点需要注意：</p><ul><li>Service是单例的；</li><li>Service由内部的<code>$injector</code>进行实例化，不需要手动实例化；</li><li>所有的Service都是保存在一个对象中，内置服务都以<code>$</code>开头，所以自定义服务不要以<code>$</code>开头，并且不要同名，否则会发生覆盖的情况，在使用第三方库的时候尤其要注意；</li><li>Service不能注入到config配置块中，配置块中只能注入供应商。</li></ul><h3 id="Provider（供应商）"><a href="#Provider（供应商）" class="headerlink" title="Provider（供应商）"></a>Provider（供应商）</h3><p>供应商用来向控制器，指令等提供服务。供应商在定义时会包含一个服务在函数内，AngularJS实例化供应商内部的服务，将其保存在变量中，之后需要注入服务时只需要到变量中获取。</p><p>AngularJS提供了一个内置对象<code>$provider</code>，这个对象上有5个属性方法： <code>provide</code>，<code>factory</code>，<code>service</code>，<code>value</code>，<code>constant</code>和<code>decorator</code>。其中前面4个都是用来创建provider的，只不过是不同写法而已。<code>constant</code>用来创建一个常量，<code>decorator</code>用来对其他服务做一些装饰修改。AngularJS也在模块对象上挂在了这几个相同的方法，就是说我们创建一个供应商或服务可以这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">angular</span><br><span class="line">  .module(<span class="string">'app'</span>)</span><br><span class="line">  .provide(...)</span><br><span class="line">  .factory(...)</span><br></pre></td></tr></table></figure><p>应用程序中所有供应商保存在内部变量<code>providerCache</code>中。关于Provider有一下几点需要注意：</p><ul><li>Provider只能注入到config配置块中，在配置块中可以对服务进行最后的修改；</li><li>注入的时候需要在定义的服务名称后面加上<code>Provider</code>，完整的供应商的名称是<code>serviceProvider</code>。</li></ul><h3 id="Injector（注入器）"><a href="#Injector（注入器）" class="headerlink" title="$Injector（注入器）"></a>$Injector（注入器）</h3><p><code>$injector</code>是实现依赖注入的关键。他是一个内置的服务，提供以下几个方法：    </p><ul><li>annotate 解析参数列表</li><li>invoke 调用函数（会自动注入依赖的服务或供应商）</li><li>instantiate 实例化对象（会自动注入依赖的服务或供应商）</li><li>get 获取实例（不存在实例则创建）</li><li>has 判断服务是否已经创建</li><li><code>$injector</code>是通过createInternalInjector方法创建的，在AngularJS内部还通过这个方法创建了两个关键的对象<code>providerInjector</code>和<code>instanceInjector</code>。<code>$injector</code>就是<code>instanceInjector</code>，用来操作服务，但是<code>$injector</code>可以被我们调用，用来处理其他的函数，比如annotate，invoke和instantiate，可以对普通的函数操作；<code>providerInjector</code>用来操作供应商。<code>get</code>方法就是从对应的变量（<code>instanceCache</code>或者<code>providerCache</code>）中获取实例。</li></ul><h2 id="Provider用法"><a href="#Provider用法" class="headerlink" title="Provider用法"></a>Provider用法</h2><p>上面说过<code>$provide</code>提供多种创建供应商的方法，但是原理都是一样，只是语法糖而已（<code>constant</code>和<code>decorator</code>除外，需要单独讨论），而这些方法都挂在在了module对象上了，所以我这里只讨论<code>moudule.provider</code>方法。 </p><p>provider方法用法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">angular</span><br><span class="line">  .module(<span class="string">'app'</span>)</span><br><span class="line">  .provider(<span class="string">'freeball'</span>, <span class="function"><span class="keyword">function</span> <span class="title">freeballProvider</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> freeballFlag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.setFreeball = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">      freeballFlag = !!value;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 必须有这个方法</span></span><br><span class="line">    <span class="keyword">this</span>.$<span class="keyword">get</span> = function freeballFactory() &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        freeball: freeballFlag </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)</span><br><span class="line">  .config(<span class="function"><span class="keyword">function</span>(<span class="params">freeballProvider</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我是提供者'</span>);</span><br><span class="line">    freeballProvider.setFreeball(<span class="literal">true</span>)</span><br><span class="line">    <span class="built_in">console</span>.dir(freeballProvider)</span><br><span class="line">  &#125;)</span><br><span class="line">  .controller(<span class="string">'homeController'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">freeball</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我是服务'</span>);</span><br><span class="line">    <span class="built_in">console</span>.dir(freeball)</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p><img src="2017-08-18_22h47_58.png" alt></p><p>查看输出结果你会发现：</p><ol><li>config中的freeballProvider好像是 <code>freeballProvider函数</code>生成的，他只有在this上面绑定的两个函数<code>setFreeball</code>和<code>$get</code></li><li>controller中的freeball好像是<code>freeballFactory</code>函数返回的对象，而且属性freeball的值不是<code>false</code>而是<code>true</code></li></ol><p>实际上，这就是Provider的含义：    </p><ol><li>它通过provider方法传入的两个参数，生成了一个带有<code>$get</code>方法的对象，这个对象就是供应商，他可以注入到config配置块中(只有<code>provider</code>和<code>constant</code>创建的供应商可以注入到config中)，对内部的变量做一些修改，这里我们把<code>freeballFlag</code>改成了<code>true</code>。    </li><li>在控制器，指令等需要注入服务的方法执行之前AngularJS会注入它们需要的服务，这些服务当然就是通过调用供应商的<code>$get</code>方法生成的了，而且只会生成一次，在不同地方注入的相同服务是同一实例。</li></ol><p>所以供应商创建服务的关键就是<code>this.$get</code>方法，他被用来调用返回他的返回值，这个返回值就是服务。其他几种创建服务的方法都会在内部添加上<code>$get</code>方法，然后调用<code>provider</code>。下面我们就会来研究以下源码，看看如何调用<code>$get</code>方法，如何实例化并注入到方法中的。</p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>可以看一下源代码，看一下AngularJS是如何创建供应商</p><h3 id="createInternalInjector方法"><a href="#createInternalInjector方法" class="headerlink" title="createInternalInjector方法"></a>createInternalInjector方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是调用createInternalInjector创建注入器的过程，两个注入器都会返回相同结构的对象，</span></span><br><span class="line"><span class="comment">// 但是由于内部返回的方法都是闭包，所以他们是对不同cache进行操作的。</span></span><br><span class="line"><span class="comment">// 可以看出分别是providerCache和instanceCache，两次调用传入的工厂方法也是不一样的。</span></span><br><span class="line">providerInjector = (providerCache.$injector =</span><br><span class="line">  createInternalInjector(providerCache, <span class="function"><span class="keyword">function</span>(<span class="params">serviceName, caller</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (angular.isString(caller)) &#123;</span><br><span class="line">      path.push(caller);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> $injectorMinErr(<span class="string">'unpr'</span>, <span class="string">'Unknown provider: &#123;0&#125;'</span>, path.join(<span class="string">' &lt;- '</span>));</span><br><span class="line">  &#125;)),</span><br><span class="line">instanceCache = &#123;&#125;,</span><br><span class="line">protoInstanceInjector =</span><br><span class="line">  <span class="comment">// 这里传入的工厂方法会根据对应供应商调用get方法返回服务</span></span><br><span class="line">  createInternalInjector(instanceCache, <span class="function"><span class="keyword">function</span>(<span class="params">serviceName, caller</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> provider = providerInjector.get(serviceName + providerSuffix, caller);</span><br><span class="line">    <span class="keyword">return</span> instanceInjector.invoke(</span><br><span class="line">        provider.$<span class="keyword">get</span>, provider, undefined, serviceName);</span><br><span class="line">  &#125;),</span><br><span class="line">instanceInjector = protoInstanceInjector;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function createInternalInjector(cache, factory) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这是获取服务的方法 </span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getService</span>(<span class="params">serviceName, caller</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cache.hasOwnProperty(serviceName)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (cache[serviceName] === INSTANTIATING) &#123;</span><br><span class="line">        <span class="keyword">throw</span> $injectorMinErr(<span class="string">'cdep'</span>, <span class="string">'Circular dependency found: &#123;0&#125;'</span>,</span><br><span class="line">                  serviceName + <span class="string">' &lt;- '</span> + path.join(<span class="string">' &lt;- '</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果已经有了直接返回</span></span><br><span class="line">      <span class="keyword">return</span> cache[serviceName];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        path.unshift(serviceName);</span><br><span class="line">        cache[serviceName] = INSTANTIATING;</span><br><span class="line">        <span class="comment">// 如果没有调用工厂方法创建，这个工厂方法就是调用两次createInternalInjector方法创建</span></span><br><span class="line">        <span class="comment">// providerInjector和instanceInjector时传入的方法。创建服务的过程就在第二次调用的方法中。</span></span><br><span class="line">        cache[serviceName] = factory(serviceName, caller);</span><br><span class="line">        <span class="keyword">return</span> cache[serviceName];</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache[serviceName] === INSTANTIATING) &#123;</span><br><span class="line">          <span class="keyword">delete</span> cache[serviceName];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        path.shift();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这是注入参数的方法</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">injectionArgs</span>(<span class="params">fn, locals, serviceName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = [],</span><br><span class="line">        <span class="comment">// 解析参数列表</span></span><br><span class="line">        $inject = createInjector.$$annotate(fn, strictDi, serviceName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, length = $inject.length; i &lt; length; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> key = $inject[i];</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> key !== <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> $injectorMinErr(<span class="string">'itkn'</span>,</span><br><span class="line">                <span class="string">'Incorrect injection token! Expected service name as string, got &#123;0&#125;'</span>, key);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// getService获取服务并添加到参数列表</span></span><br><span class="line">      args.push(locals &amp;&amp; locals.hasOwnProperty(key) ? locals[key] :</span><br><span class="line">                                                        getService(key, serviceName));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> args;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">invoke</span>(<span class="params">fn, self, locals, serviceName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> locals === <span class="string">'string'</span>) &#123;</span><br><span class="line">      serviceName = locals;</span><br><span class="line">      locals = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> args = injectionArgs(fn, locals, serviceName);</span><br><span class="line">    <span class="keyword">if</span> (isArray(fn)) &#123;</span><br><span class="line">      fn = fn[fn.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isClass(fn)) &#123;</span><br><span class="line">      <span class="comment">// http://jsperf.com/angularjs-invoke-apply-vs-switch</span></span><br><span class="line">      <span class="comment">// #5388</span></span><br><span class="line">      <span class="keyword">return</span> fn.apply(self, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      args.unshift(<span class="literal">null</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> (<span class="built_in">Function</span>.prototype.bind.apply(fn, args))();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这是实例化供应商的方法</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">instantiate</span>(<span class="params">Type, locals, serviceName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ctor = (isArray(Type) ? Type[Type.length - <span class="number">1</span>] : Type);</span><br><span class="line">    <span class="comment">// 注入参数</span></span><br><span class="line">    <span class="keyword">var</span> args = injectionArgs(Type, locals, serviceName);</span><br><span class="line">    args.unshift(<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 这里用了new操作符创建了供应商，所以我们看到freeballProvider对象上面只有绑定到this上的方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> (<span class="built_in">Function</span>.prototype.bind.apply(ctor, args))();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    invoke: invoke,</span><br><span class="line">    instantiate: instantiate,</span><br><span class="line">    <span class="keyword">get</span>: getService,</span><br><span class="line">    annotate: createInjector.$$annotate,</span><br><span class="line">    has: function(name) &#123;</span><br><span class="line">      <span class="keyword">return</span> providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="供应商实例创建过程"><a href="#供应商实例创建过程" class="headerlink" title="供应商实例创建过程"></a>供应商实例创建过程</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是provider方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">provider</span>(<span class="params">name, provider_</span>) </span>&#123;</span><br><span class="line">  assertNotHasOwnProperty(name, <span class="string">'service'</span>);</span><br><span class="line">  <span class="keyword">if</span> (isFunction(provider_) || isArray(provider_)) &#123;</span><br><span class="line">    <span class="comment">// 这里调用instantiate方法来生成供应商Provider</span></span><br><span class="line">    provider_ = providerInjector.instantiate(provider_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!provider_.$<span class="keyword">get</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> $injectorMinErr(<span class="string">'pget'</span>, <span class="string">"Provider '&#123;0&#125;' must define $get factory method."</span>, name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这里将你定义的名字加上“Provider”后缀，然后将生成的provider_添加到一个缓存对象中</span></span><br><span class="line">  <span class="comment">// 所以其实我们创建的freeball供应商其实被保存成了freeballProvider，放在provideCache中</span></span><br><span class="line">  <span class="keyword">return</span> providerCache[name + providerSuffix] = provider_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务实例创建过程"><a href="#服务实例创建过程" class="headerlink" title="服务实例创建过程"></a>服务实例创建过程</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我这里只以控制器为例</span></span><br><span class="line"><span class="comment">// 这是初始化控制器对象的代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">$controllerInit</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里调用了$injector.invoke，通过调试，结合invoke方法的内部实现，不难发现angularjs在调用控制</span></span><br><span class="line">  <span class="comment">// 器之前，对参数进行了解析和实例化，最后注入到函数中，同时保存在了cache中，以保证下次注入不需</span></span><br><span class="line">  <span class="comment">// 要重新创建</span></span><br><span class="line">  <span class="keyword">var</span> result = $injector.invoke(expression, instance, locals, <span class="keyword">constructor</span>);</span><br><span class="line">  if (result !== instance &amp;&amp; (isObject(result) || isFunction(result))) &#123;</span><br><span class="line">    instance = result;</span><br><span class="line">    <span class="keyword">if</span> (identifier) &#123;</span><br><span class="line">      <span class="comment">// If result changed, re-assign controllerAs value to scope.</span></span><br><span class="line">      addIdentifier(locals, identifier, instance, <span class="keyword">constructor</span> || expression.name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return instance;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  instance: instance,</span><br><span class="line">  identifier: identifier</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上只是创建供应商和服务大概流程。需要好好的研究源码的结构和调用栈才能理解它的执行过程。当然不排除我有可能理解错误，仅供参考。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;依赖注入是AngularJS的四大特性之一，在理解AngularJS如果实现依赖注入之前需要知道一些名词概念。&lt;/p&gt;
&lt;h
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://blog.betterliyu.site/categories/JavaScript/"/>
    
    
      <category term="AngularJS" scheme="https://blog.betterliyu.site/tags/AngularJS/"/>
    
  </entry>
  
</feed>
